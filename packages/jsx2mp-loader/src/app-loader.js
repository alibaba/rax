const { readJSONSync, writeJSONSync, writeFileSync, readFileSync, existsSync, mkdirSync } = require('fs-extra');
const { relative, join, dirname } = require('path');
const compiler = require('jsx-compiler');
const { getOptions } = require('loader-utils');
const moduleResolve = require('./utils/moduleResolve');
const { removeExt } = require('./utils');


function createImportStatement(req) {
  return `import '${req}';`;
}

function generateDependencies(dependencies) {
  return Object
    .keys(dependencies)
    .map(mod => createImportStatement(mod))
    .join('\n');
}

function getRelativePath(filePath) {
  let relativePath;
  if (filePath[0] === '/') {
    relativePath = `.${filePath}`;
  } else if (filePath[0] === '.') {
    relativePath = filePath;
  } else {
    relativePath = `./${filePath}`;
  }
  return relativePath;
}

module.exports = function appLoader(content) {
  const loaderOptions = getOptions(this);
  const { entryPath } = loaderOptions;
  const appConfigPath = removeExt(this.resourcePath) + '.json';
  const rawContent = readFileSync(this.resourcePath, 'utf-8');
  const config = readJSONSync(appConfigPath);

  const distPath = this._compiler.outputPath;
  if (!existsSync(distPath)) mkdirSync(distPath);

  const sourcePath = join(this.rootContext, entryPath);
  const relativeSourcePath = relative(sourcePath, this.resourcePath);
  const targetFilePath = join(distPath, relativeSourcePath);

  const targetFileDir = dirname(join(distPath, relative(sourcePath, this.resourcePath)));

  const compilerOptions = Object.assign({}, compiler.baseOptions, {
    resourcePath: this.resourcePath,
    distPath,
    sourcePath,
    type: 'app',
  });
  const transformed = compiler(rawContent, compilerOptions);

  this.addDependency(appConfigPath);

  const transformedAppConfig = transformAppConfig(entryPath, config);
  writeFileSync(join(distPath, 'app.js'), transformed.code);
  writeJSONSync(join(distPath, 'app.json'), transformedAppConfig, { spaces: 2 });

  if (transformed.style) {
    writeFileSync(join(distPath, 'app.acss'), transformed.style);
  }

  return [
    `/* Generated by JSX2MP AppLoader, sourceFile: ${this.resourcePath}. */`,
    generateDependencies(transformed.imported),
  ].join('\n');
};

function transformAppConfig(entryPath, originalConfig) {
  const config = {};
  for (let key in originalConfig) {
    const value = originalConfig[key];
    switch (key) {
      case 'routes':
        const pages = [];
        if (Array.isArray(value)) {
          // only resolve first level of routes.
          value.forEach(({ path, component }) => {
            pages.push(moduleResolve(entryPath, getRelativePath(component)));
          });
        }
        config.pages = pages;
        break;

      default:
        config[key] = value; break;
    }
  }

  return config;
}
